
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>SOM</title>
    <script>
      
    </script>


    <link href="css/style.css" rel="stylesheet" type="text/css">

    <script src="vendor/jquery-2.1.3.min.js"></script>
    <script src="vendor/d3.v3.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="vendor/hexbin.js"></script>
    <script type="text/javascript" src="vendor/lodash.min.js"></script>
    <script type="text/javascript" src="vendor/parallel.js"></script>
    
  
    <script type="text/javascript" src="SOM.js"></script>
    
  </head>
  <body>

    <!-- SPINNER -->
    <div id="spinner-container">
      <div class="spinner">
        <div class="double-bounce1"></div>
        <div class="double-bounce2"></div>
      </div>
    </div>




    <div id="planes"></div>
    
  


    <script type="text/javascript">


      
      var p;
      var dummy_data;
      var data_columns = [];
      var sampleids = [];


      var start_demo = function() {



        d3.json("data/sampledata.json", function(error, json) {


          if (error) return console.warn(error);


          var training_vars = ["XXL-VLDL-L","XL-VLDL-L","L-VLDL-L","M-VLDL-L","S-VLDL-L","XS-VLDL-L","IDL-L","L-LDL-L","M-LDL-L","S-LDL-L","XL-HDL-L","L-HDL-L","M-HDL-L","S-HDL-L"];
        
          var data_columns = prepare_data_columns(json.result.values, training_vars);



          _s = SOM.create(7,9, sampleids, data_columns);



          function train_som(som_object) {
            SOM.train(som_object);
            return som_object;
          }

          function finish_training(trained_som) {
            _s = trained_som;
            make_component_planes();
          }

          
          p = new Parallel(_s, {
            evalPath: 'eval.js'
          })
          .require('vendor/lodash.min.js')
          .require('SOM.js')
          .map(train_som)
          .then(finish_training);

          


          function make_component_planes() {

            function get_component_plane(data) {
                console.log('starting component plane calculation');
                
                return SOM.calculate_component_plane(global.env.som, global.env.sampleids, data.d, data.n);
            }

            function draw(results) {
              console.log('component plane results');
                console.log(results);
                $("#spinner-container").hide();
                for(i in results) {
                  draw_plane(results[i], '#planes');
                }
            }

            var p = new Parallel( [ {n: 'Alanine', d: dummy_data.Ala}, 
                                    {n: 'HDL-C', d: dummy_data['HDL-C'] }, 
                                    {n: 'Phenylalanine', d: dummy_data['Phe']},
                                    {n: 'Serum-TG', d: dummy_data['Serum-TG']},
                                    {n: 'Glucose', d: dummy_data['Glc']},
                                    {n: 'LDL-C', d: dummy_data['LDL-C']},
                                    {n: 'Tyrosine', d: dummy_data['Tyr']},
                                    {n: 'Remnant-C', d: dummy_data['Remnant-C']},
                                    ], {
              evalPath: 'eval.js',
              env : {
                som: _s,
                sampleids: sampleids
              }
            })
            .require('vendor/lodash.min.js')
            .require('SOM.js')
            .map(get_component_plane)
            .then(draw);


          }

              
        });

      }






      function prepare_data_columns(dataobjectarray, training_vars) {

        var all_variables = [];

        for(var key in dataobjectarray[0].variables) {
          all_variables.push(key);

        }

        var no_missing_data_array = [];
        var missing = false;

        for(var i=0;i<dataobjectarray.length;i++) {

          missing = false;

          for(var j=0;j<all_variables.length;j++) {
            if(isNaN(parseFloat(dataobjectarray[i].variables[all_variables[j]])) || 
              dataobjectarray[i].variables[all_variables[j]] == 0
              ) {
              missing = true;
              break;
            } 
            
          }

          if(!missing) {
            no_missing_data_array.push(dataobjectarray[i]);
          }
        }

        for(var j=0;j<training_vars.length;j++) { 
            data_columns[j] = [];
        }

        for(var i=0;i<no_missing_data_array.length;i++) {
          
          for(var j=0;j<training_vars.length;j++) {
            data_columns[j][i] = no_missing_data_array[i].variables[training_vars[j]];
          }

          sampleids[i] = { 'dataset' : no_missing_data_array[i].dataset, 'sampleid'  : no_missing_data_array[i].sampleid };
        }

        dummy_data = {};

        for(var key in dataobjectarray[0].variables) {
          dummy_data[key] = new Float32Array(no_missing_data_array.length);
          for(var i=0;i<no_missing_data_array.length;i++) {
            dummy_data[key][i] = no_missing_data_array[i].variables[key];
          }
        }

        return data_columns;

      }



      function draw_plane(plane, elem) {

        var labelFormat = d3.format('.2f');

        var margin = {
          top: 30,
          right: 30,
          bottom: 30,
          left: 30
        },
        
        
        width = 500;
        height = width * 0.75;

        var rows = plane.size.m;
        var cols = plane.size.n;

        var hexRadius = Math.floor((width / cols)*0.5);
        var points = [];



        for(var k in plane.cells)  {
            var cell = plane.cells[k];
            var datarow = [hexRadius * cell.x * 1.75, hexRadius * cell.y * 1.5, cell.color];
            points.push(datarow);
          }


        


        var hexbin = d3.hexbin()
            .radius(hexRadius);


        var container = d3.select(elem).append("div");

        container.append("p").attr("class","variable").text(plane.variable);

        var svg = container.append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        svg.append("g")
            .selectAll(".hexagon")
            .data(hexbin(points))
            .enter().append("path")
            .attr("class", "hexagon")
            .attr("d", function (d) {
            return "M" + d.x + "," + d.y + hexbin.hexagon();
        })
            .attr("stroke", "#fff")
            .attr("stroke-width", "2px")
            .style("fill", function (d) {
              return d[0][2];
            /*return d3.rgb(255-d[0][2]*255,255-d[0][2]*255,255-d[0][2]*255).toString(); */
        });



        svg.append("g")
              .selectAll(".label")
              .data(plane.labels)
              .enter()
              .append("text")
              .attr("class", "label noselect")
              .attr('text-anchor', 'middle')
              .attr('alignment-baseline', 'middle')
              .attr("x", function(d) { 
                var x = d.x;
                var y = d.y;
                if( (y % 2) === 0 ) { return x*hexRadius*1.75; }
                if( (y % 2) === 1 ) { return hexRadius*0.75 + x*hexRadius*1.75; }
              })
              .attr("y", function(d) { 
                return (d.y) * hexRadius * 1.5;
              })
              .style("fill", function(d) { return d.color; })
              .text( function(d) { return labelFormat( +d.label ); });              
      }




      start_demo();


    </script>


  </body>

</html>
